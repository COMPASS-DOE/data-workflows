---
title: "L1a"
author: "COMPASS workflows team"
title-block-banner: true
params:
  html_outfile: "L1a.html"
  DATA_ROOT: "data_TEST/"
  L1_NORMALIZE: "L1_normalize/"
  L1A: "L1a/"
  debug: false
  remove_input_files: false
  logfile: ""
date: now
date-format: "YYYY-MM-DD HH:mm:ssZ"
format: 
  html:
    code-fold: true
editor: visual
---

This script

-   Reads in all the L1_normalize files

-   Compiles and writes them out into separate <year><month><site> files

## Initializing

```{r init}
#| include: false

library(compasstools)
if(!exists("scan_folders") | !exists("unit_conversion")) {
    stop("Please update to latest version of compasstools!\n",
         "devtools::install_github('COMPASS-DOE/compasstools')")
}

source("helpers.R")

L1_NORMALIZE <- file.path(params$DATA_ROOT, params$L1_NORMALIZE)
dirs_to_process <- scan_folders(L1_NORMALIZE)

L1A <- file.path(params$DATA_ROOT, params$L1A)

```

I see `r length(dirs_to_process)` directories to process in `r L1_NORMALIZE`.

Output directory is `r L1A`.

HTML outfile is "`r params$html_outfile`".

## Processing

```{r processing}
errors <- 0

f <- function(dir_name, dirs_to_process, out_dir) {
    message(Sys.time(), " Processing ", basename(dir_name))
    d <- dirs_to_process[[dir_name]]
    message("\tIt has ", length(d), " files")
    
    # Read all files in a folder
    # Note that we're forcing `value` and `value_raw` to be character, so that
    # everything can be stacked into a single data frame
    dat_raw <- read_csv_group(d,
                              remove_input_files = params$remove_input_files, 
                              col_types = "ccTccccccccl")
    errors <<- errors + attr(dat_raw, "errors")
    
    # File-based summary
    message("\tTotal data: ", nrow(dat_raw), " rows, ", ncol(dat_raw), " columns")
    smry <- data.frame(Dir = dir_name, 
                       Files = length(d), 
                       Rows = nrow(dat_raw))
    
    # Remove duplicate rows (e.g. from multiple datalogger downloads)
    # With the unique ID generation in L0.qmd, this should never happen?
    dat <- distinct(dat_raw)
    message("\tRemoved ", nrow(dat_raw) - nrow(dat), " duplicate rows")
    
    # Make sure Site and Plot columns, if present, are on the left
    lefts <- intersect(c("Site", "Plot"), colnames(dat))
    rights <- setdiff(colnames(dat), lefts)
    dat <- dat[c(lefts, rights)]
    # Remove Logger, Table, and loggernet_variable if present
    dat <- dat[setdiff(colnames(dat), 
                       c("Logger", "Table", "loggernet_variable"))]
    # And finally, sort
    dat <- dat[order(dat$Site, dat$TIMESTAMP, dat$design_link),]
    
    write_to_folders(dat, 
                     root_dir = out_dir, 
                     data_level = "L1a",
                     site = dat$Site[1])
    
    return(smry)
}

log_info("About to L1a", logfile = params$logfile)
tryCatch({
out <- lapply(names(dirs_to_process), f, 
              dirs_to_process = dirs_to_process, out_dir = L1A)
},
error = function(e) {
    log_warning("L1a: an error occurred!", logfile = params$logfile)
    log_info(as.character(e), logfile = params$logfile)
    stop(e)
})
```

## File summary

```{r summary}
#| echo: false
#| output: asis
if(errors) {
    cat("### WARNING: ", errors, " file read/write error(s)\n")
    log_warning(paste("File read/write error(s)", params$html_outfile), 
                logfile = params$logfile)
}
```

## Output summary

```{r output_summary_table}
out_df <- do.call("rbind", out)
knitr::kable(out_df)
```

## Reproducibility

```{r reproducibility}
sessionInfo()
```
